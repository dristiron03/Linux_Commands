<!DOCTYPE html>
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Regex Tutorial - \b Word Boundaries</title>
<link rel="alternate" media="only screen and (max-device-width: 979px)" href="https://regular-expressions.mobi/wordboundaries.html">
<script src="Regex%20Tutorial%20-%20_b%20Word%20Boundaries_files/osd.js"></script><script src="Regex%20Tutorial%20-%20_b%20Word%20Boundaries_files/show_ads_impl.js" id="google_shimpl"></script><script src="Regex%20Tutorial%20-%20_b%20Word%20Boundaries_files/ca-pub-7485249680256358.js"></script><script type="text/javascript">if (screen.width < 980) window.location.replace("//regular-expressions.mobi/wordboundaries.html?wlr=1");</script><script src="Regex%20Tutorial%20-%20_b%20Word%20Boundaries_files/regex.js" type="text/javascript"></script>
<link rel="alternate" type="application/rss+xml" title="Regex Guru" href="http://www.regexguru.com/feed/">
<meta name="Author" content="Jan Goyvaerts">
<meta name="Description" content="In regular expressions, \b anchors the regex at a word boundary or the position between a word and a non-word character, or vice versa.">
<meta name="Keywords" content="">
<link rel="StyleSheet" href="Regex%20Tutorial%20-%20_b%20Word%20Boundaries_files/regex.css" type="text/css">
<link rel="preload" href="Regex%20Tutorial%20-%20_b%20Word%20Boundaries_files/integrator.js" as="script"><script type="text/javascript" src="Regex%20Tutorial%20-%20_b%20Word%20Boundaries_files/integrator.js"></script><link rel="preload" href="Regex%20Tutorial%20-%20_b%20Word%20Boundaries_files/integrator_002.js" as="script"><script type="text/javascript" src="Regex%20Tutorial%20-%20_b%20Word%20Boundaries_files/integrator_002.js"></script><link rel="preload" href="Regex%20Tutorial%20-%20_b%20Word%20Boundaries_files/show_ads_impl.js" as="script"></head>
<body text="black" bgcolor="white">
<script type="text/javascript">window.onresize = movecontent;</script>
<div id="top"></div>
<div id="btntop"><table cellspacing="0" cellpadding="0" border="0" align="center"><tbody><tr><td><a href="https://www.regular-expressions.info/quickstart.html" target="_top"><div onmouseover="this.style.backgroundColor='#FFA000';" onmouseout="this.style.backgroundColor='#A03300';return false;">Quick&nbsp;Start</div></a></td><td><a href="https://www.regular-expressions.info/tutorial.html" target="_top"><div onmouseover="this.style.backgroundColor='#FFA000';" onmouseout="this.style.backgroundColor='#A03300';return false;">Tutorial</div></a></td><td><a href="https://www.regular-expressions.info/tools.html" target="_top"><div onmouseover="this.style.backgroundColor='#FFA000';" onmouseout="this.style.backgroundColor='#A03300';return false;">Tools&nbsp;&amp;&nbsp;Languages</div></a></td><td><a href="https://www.regular-expressions.info/examples.html" target="_top"><div onmouseover="this.style.backgroundColor='#FFA000';" onmouseout="this.style.backgroundColor='#A03300';return false;">Examples</div></a></td><td><a href="https://www.regular-expressions.info/reference.html" target="_top"><div onmouseover="this.style.backgroundColor='#FFA000';" onmouseout="this.style.backgroundColor='#A03300';return false;">Reference</div></a></td><td><a href="https://www.regular-expressions.info/books.html" target="_top"><div onmouseover="this.style.backgroundColor='#FFA000';" onmouseout="this.style.backgroundColor='#A03300';return false;">Book&nbsp;Reviews</div></a></td></tr></tbody></table></div>
<div id="bodytext" style="left: 407px; width: 748px;">
<script type="text/javascript">movecontent();</script>
<div class="topad"><a href="https://www.regexbuddy.com/create.html" target="_top"><img src="Regex%20Tutorial%20-%20_b%20Word%20Boundaries_files/rxbtutorial100.png" srcset="ads/728/rxbtutorial100.png 1x, ads/728/rxbtutorial125.png 1.25x, ads/728/rxbtutorial150.png 1.5x, ads/728/rxbtutorial175.png 1.75x, ads/728/rxbtutorial200.png 2x, ads/728/rxbtutorial250.png 2.5x, ads/728/rxbtutorial300.png 3x, ads/728/rxbtutorial350.png 3.5x, ads/728/rxbtutorial400.png 4x" alt="RegexBuddy—Better than a regular expression tutorial!"></a></div> <h1>Word Boundaries</h1> <p>The metacharacter <tt class="code"><span class="regexspecial">\b</span></tt> is an <a href="https://www.regular-expressions.info/anchors.html" target="_top">anchor</a> like the caret and the dollar sign. It matches at a position that is called a "word boundary". This match is zero-length.</p> <p>There are three different positions that qualify as word boundaries:</p> <ul> <li>Before the first character in the string, if the first character is a word character.</li> <li>After the last character in the string, if the last character is a word character.</li> <li>Between two characters in the string, where one is a word character and the other is not a word character.</li> </ul> <p>Simply put: <tt class="code"><span class="regexspecial">\b</span></tt> allows you to perform a "whole words only" search using a regular expression in the form of <tt class="code"><span class="regexspecial">\b</span><span class="regexplain">word</span><span class="regexspecial">\b</span></tt>.
 A "word character" is a character that can be used to form words. All 
characters that are not "word characters" are "non-word characters".</p> <p>Exactly
 which characters are word characters depends on the regex flavor you're
 working with. In most flavors, characters that are matched by the <a href="https://www.regular-expressions.info/shorthand.html" target="_top">short-hand character class</a> <tt class="code"><span class="regexspecial">\w</span></tt> are the characters that are treated as word characters by word boundaries. <a href="https://www.regular-expressions.info/java.html" target="_top">Java</a> is an exception. Java supports Unicode for <tt class="code"><span class="regexspecial">\b</span></tt> but not for <tt class="code"><span class="regexspecial">\w</span></tt>.</p> <p>Most
 flavors, except the ones discussed below, have only one metacharacter 
that matches both before a word and after a word. This is because any 
position between characters can never be both at the start and at the 
end of a word. Using only one operator makes things easier for you.</p> <p>Since digits are considered to be word characters, <tt class="code"><span class="regexspecial">\b</span><span class="regexplain">4</span><span class="regexspecial">\b</span></tt> can be used to match a 4 that is not part of a larger number. This regex does not match <tt class="string">44 sheets of a4</tt>. So saying "<tt class="code"><span class="regexspecial">\b</span></tt> matches before and after an alphanumeric sequence" is more exact than saying "before and after a word".</p> <p><tt class="code"><span class="regexspecial">\B</span></tt> is the negated version of <tt class="code"><span class="regexspecial">\b</span></tt>. <tt class="code"><span class="regexspecial">\B</span></tt> matches at every position where <tt class="code"><span class="regexspecial">\b</span></tt> does not. Effectively, <tt class="code"><span class="regexspecial">\B</span></tt> matches at any position between two word characters as well as at any position between two non-word characters.</p> <div class="adsense">
<script type="text/javascript"><!--
google_ad_client = "pub-7485249680256358";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "FF6600";
google_color_bg = "FFF4E8";
google_color_link = "EE5500";
google_color_text = "000000";
google_color_url = "803300";
google_ui_features = "rc:0";
//-->
</script>
<script type="text/javascript" src="Regex%20Tutorial%20-%20_b%20Word%20Boundaries_files/show_ads.js">
</script><ins id="aswift_0_expand" style="display:inline-table;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><ins id="aswift_0_anchor" style="display:block;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;border:0px;width:728px;height:90px;" width="728" height="90" frameborder="0"></iframe></ins></ins>
</div><h2>Looking Inside The Regex Engine</h2> <p>Let's see what happens when we apply the regex <tt class="code"><span class="regexspecial">\b</span><span class="regexplain">is</span><span class="regexspecial">\b</span></tt> to the string <tt class="string">This island is beautiful</tt>. The engine starts with the first token <tt class="code"><span class="regexspecial">\b</span></tt> at the first character <tt class="string">T</tt>. Since this token is zero-length, the position before the character is inspected. <tt class="code"><span class="regexspecial">\b</span></tt>
 matches here, because the T is a word character and the character 
before it is the void before the start of the string. The engine 
continues with the next token: the literal <tt class="code"><span class="regexplain">i</span></tt>. The engine does not advance to the next character in the string, because the previous regex token was zero-length. <tt class="code"><span class="regexplain">i</span></tt> does not match <tt class="string">T</tt>, so the engine retries the first token at the next character position.</p> <p><tt class="code"><span class="regexspecial">\b</span></tt> cannot match at the position between the <tt class="string">T</tt> and the <tt class="string">h</tt>. It cannot match between the <tt class="string">h</tt> and the <tt class="string">i</tt> either, and neither between the <tt class="string">i</tt> and the <tt class="string">s</tt>.</p> <p>The next character in the string is a space. <tt class="code"><span class="regexspecial">\b</span></tt> matches here because the space is not a word character, and the preceding character is. Again, the engine continues with the <tt class="code"><span class="regexplain">i</span></tt> which does not match with the space.</p> <p>Advancing a character and restarting with the first regex token, <tt class="code"><span class="regexspecial">\b</span></tt> matches between the space and the second <tt class="string">i</tt> in the string. Continuing, the regex engine finds that <tt class="code"><span class="regexplain">i</span></tt> matches <tt class="match">i</tt> and <tt class="code"><span class="regexplain">s</span></tt> matches <tt class="match">s</tt>. Now, the engine tries to match the second <tt class="code"><span class="regexspecial">\b</span></tt> at the position before the <tt class="string">l</tt>.
 This fails because this position is between two word characters. The 
engine reverts to the start of the regex and advances one character to 
the <tt class="string">s</tt> in <tt class="string">island</tt>. Again, the <tt class="code"><span class="regexspecial">\b</span></tt> fails to match and continues to do so until the second space is reached. It matches there, but matching the <tt class="code"><span class="regexplain">i</span></tt> fails.</p> <p>But <tt class="code"><span class="regexspecial">\b</span></tt> matches at the position before the third <tt class="string">i</tt> in the string. The engine continues, and finds that <tt class="code"><span class="regexplain">i</span></tt> matches <tt class="match">i</tt> and <tt class="code"><span class="regexplain">s</span></tt> matches <tt class="match">s</tt>. The last token in the regex, <tt class="code"><span class="regexspecial">\b</span></tt>,
 also matches at the position before the third space in the string 
because the space is not a word character, and the character before it 
is.</p> <p>The engine has successfully matched the word <tt class="match">is</tt> in our string, skipping the two earlier occurrences of the characters i and s. If we had used the regular expression <tt class="code"><span class="regexplain">is</span></tt>, it would have matched the <tt class="match">is</tt> in <tt class="string">This</tt>.</p> <a name="tcl"></a><div class="adsense">
<script type="text/javascript"><!--
google_ad_client = "pub-7485249680256358";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "FF6600";
google_color_bg = "FFF4E8";
google_color_link = "EE5500";
google_color_text = "000000";
google_color_url = "803300";
google_ui_features = "rc:0";
//-->
</script>
<script type="text/javascript" src="Regex%20Tutorial%20-%20_b%20Word%20Boundaries_files/show_ads.js">
</script><ins id="aswift_1_expand" style="display:inline-table;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;border:0px;width:728px;height:90px;" width="728" height="90" frameborder="0"></iframe></ins></ins>
</div><h2>Tcl Word Boundaries</h2> <p>Word boundaries, as described above, are supported by most regular expression flavors. Notable exceptions are the <a href="https://www.regular-expressions.info/posix.html" target="_top">POSIX</a> and <a href="https://www.regular-expressions.info/xml.html" target="_top">XML Schema</a> flavors, which don't support word boundaries at all. <a href="https://www.regular-expressions.info/tcl.html" target="_top">Tcl</a> uses a different syntax.</p> <p>In Tcl, <tt class="code"><span class="regexspecial">\b</span></tt> matches a backspace character, just like <tt class="code"><span class="regexspecial">\x08</span></tt> in most regex flavors (including Tcl's). <tt class="code"><span class="regexspecial">\B</span></tt> matches a single backslash character in Tcl, just like <tt class="code"><span class="regexescaped">\\</span></tt> in all other regex flavors (and Tcl too).</p> <p>Tcl uses the letter "y" instead of the letter "b" to match word boundaries. <tt class="code"><span class="regexspecial">\y</span></tt> matches at any word boundary position, while <tt class="code"><span class="regexspecial">\Y</span></tt> matches at any position that is not a word boundary. These Tcl regex tokens match exactly the same as <tt class="code"><span class="regexspecial">\b</span></tt> and <tt class="code"><span class="regexspecial">\B</span></tt> in Perl-style regex flavors. They don't discriminate between the start and the end of a word.</p> <p>Tcl has two more word boundary tokens that do discriminate between the start and end of a word. <tt class="code"><span class="regexspecial">\m</span></tt>
 matches only at the start of a word. That is, it matches at any 
position that has a non-word character to the left of it, and a word 
character to the right of it. It also matches at the start of the string
 if the first character in the string is a word character. <tt class="code"><span class="regexspecial">\M</span></tt>
 matches only at the end of a word. It matches at any position that has a
 word character to the left of it, and a non-word character to the right
 of it. It also matches at the end of the string if the last character 
in the string is a word character.</p> <p>The only regex engine that supports Tcl-style word boundaries (besides Tcl itself) is the <a href="https://www.regular-expressions.info/jgsoft.html" target="_top">JGsoft engine</a>. In <a href="https://www.regular-expressions.info/powergrep.html" target="_top">PowerGREP</a> and <a href="https://www.regular-expressions.info/editpadpro.html" target="_top">EditPad Pro</a>, <tt class="code"><span class="regexspecial">\b</span></tt> and <tt class="code"><span class="regexspecial">\B</span></tt> are Perl-style word boundaries, while <tt class="code"><span class="regexspecial">\y</span></tt>, <tt class="code"><span class="regexspecial">\Y</span></tt>, <tt class="code"><span class="regexspecial">\m</span></tt> and <tt class="code"><span class="regexspecial">\M</span></tt> are Tcl-style word boundaries.</p> <p>In most situations, the lack of <tt class="code"><span class="regexspecial">\m</span></tt> and <tt class="code"><span class="regexspecial">\M</span></tt> tokens is not a problem. <tt class="code"><span class="regexspecial">\y</span><span class="regexplain">word</span><span class="regexspecial">\y</span></tt> finds "whole words only" occurrences of "word" just like <tt class="code"><span class="regexspecial">\m</span><span class="regexplain">word</span><span class="regexspecial">\M</span></tt> would. <tt class="code"><span class="regexspecial">\M</span><span class="regexplain">word</span><span class="regexspecial">\m</span></tt> could never match anywhere, since <tt class="code"><span class="regexspecial">\M</span></tt> never matches at a position followed by a word character, and <tt class="code"><span class="regexspecial">\m</span></tt> never at a position preceded by one. If your regular expression needs to match characters before or after <tt class="code"><span class="regexspecial">\y</span></tt>,
 you can easily specify in the regex whether these characters should be 
word characters or non-word characters. If you want to match any word, <tt class="code"><span class="regexspecial">\y</span><span class="regexspecial">\w</span><span class="regexspecial">+</span><span class="regexspecial">\y</span></tt> gives the same result as <tt class="code"><span class="regexspecial">\m</span><span class="regexspecial">.</span><span class="regexspecial">+</span><span class="regexspecial">\M</span></tt>. Using <tt class="code"><span class="regexspecial">\w</span></tt> instead of the dot automatically restricts the first <tt class="code"><span class="regexspecial">\y</span></tt> to the start of a word, and the second <tt class="code"><span class="regexspecial">\y</span></tt> to the end of a word. Note that <tt class="code"><span class="regexspecial">\y</span><span class="regexspecial">.</span><span class="regexspecial">+</span><span class="regexspecial">\y</span></tt>
 would not work. This regex matches each word, and also each sequence of
 non-word characters between the words in your subject string. That 
said, if your flavor supports <tt class="code"><span class="regexspecial">\m</span></tt> and <tt class="code"><span class="regexspecial">\M</span></tt>, the regex engine could apply <tt class="code"><span class="regexspecial">\m</span><span class="regexspecial">\w</span><span class="regexspecial">+</span><span class="regexspecial">\M</span></tt> slightly faster than <tt class="code"><span class="regexspecial">\y</span><span class="regexspecial">\w</span><span class="regexspecial">+</span><span class="regexspecial">\y</span></tt>, depending on its internal optimizations.</p> <p>If your regex flavor supports <a href="https://www.regular-expressions.info/lookaround.html" target="_top">lookahead and lookbehind</a>, you can use <tt class="code"><span class="regexnest1">(?&lt;!</span><span class="regexspecial">\w</span><span class="regexnest1">)</span><span class="regexnest1">(?=</span><span class="regexspecial">\w</span><span class="regexnest1">)</span></tt> to emulate Tcl's <tt class="code"><span class="regexspecial">\m</span></tt> and <tt class="code"><span class="regexnest1">(?&lt;=</span><span class="regexspecial">\w</span><span class="regexnest1">)</span><span class="regexnest1">(?!</span><span class="regexspecial">\w</span><span class="regexnest1">)</span></tt> to emulate <tt class="code"><span class="regexspecial">\M</span></tt>. Though quite a bit more verbose, these lookaround constructs match exactly the same as Tcl's word boundaries.</p> <p>If your flavor has lookahead but not lookbehind, and also has Perl-style word boundaries, you can use <tt class="code"><span class="regexspecial">\b</span><span class="regexnest1">(?=</span><span class="regexspecial">\w</span><span class="regexnest1">)</span></tt> to emulate Tcl's <tt class="code"><span class="regexspecial">\m</span></tt> and <tt class="code"><span class="regexspecial">\b</span><span class="regexnest1">(?!</span><span class="regexspecial">\w</span><span class="regexnest1">)</span></tt> to emulate <tt class="code"><span class="regexspecial">\M</span></tt>. <tt class="code"><span class="regexspecial">\b</span></tt>
 matches at the start or end of a word, and the lookahead checks if the 
next character is part of a word or not. If it is we're at the start of a
 word. Otherwise, we're at the end of a word.</p> <a name="gnu"></a><div class="adsense">
<script type="text/javascript"><!--
google_ad_client = "pub-7485249680256358";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "FF6600";
google_color_bg = "FFF4E8";
google_color_link = "EE5500";
google_color_text = "000000";
google_color_url = "803300";
google_ui_features = "rc:0";
//-->
</script>
<script type="text/javascript" src="Regex%20Tutorial%20-%20_b%20Word%20Boundaries_files/show_ads.js">
</script><ins id="aswift_2_expand" style="display:inline-table;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><ins id="aswift_2_anchor" style="display:block;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_2" name="aswift_2" style="left:0;position:absolute;top:0;border:0px;width:728px;height:90px;" width="728" height="90" frameborder="0"></iframe></ins></ins>
</div><h2>GNU Word Boundaries</h2> <p>The <a href="https://www.regular-expressions.info/gnu.html" target="_top">GNU extensions</a> to POSIX regular expressions add support for the <tt class="code"><span class="regexspecial">\b</span></tt> and <tt class="code"><span class="regexspecial">\B</span></tt> word boundaries, as described above. GNU also uses its own syntax for start-of-word and end-of-word boundaries. <tt class="code"><span class="regexspecial">\&lt;</span></tt> matches at the start of a word, like Tcl's <tt class="code"><span class="regexspecial">\m</span></tt>. <tt class="code"><span class="regexspecial">\&gt;</span></tt> matches at the end of a word, like Tcl's <tt class="code"><span class="regexspecial">\M</span></tt>.</p> <p><a href="https://www.regular-expressions.info/boost.html" target="_top">Boost</a> also treats <tt class="code"><span class="regexspecial">\&lt;</span></tt> and <tt class="code"><span class="regexspecial">\&gt;</span></tt> as word boundaries when using the ECMAScript, extended, egrep, or awk grammar.</p> <a name="posix"></a><h2>POSIX Word Boundaries</h2> <p>The <a href="https://www.regular-expressions.info/posix.html" target="_top">POSIX</a> standard defines <tt class="code"><span class="regexspecial">[[:&lt;:]]</span></tt> as a start-of-word boundary, and <tt class="code"><span class="regexspecial">[[:&gt;:]]</span></tt> as an end-of-word boundary. Though the syntax is borrowed from <a href="https://www.regular-expressions.info/posixbrackets.html" target="_top">POSIX bracket expressions</a>,
 these tokens are word boundaries that have nothing to do with and 
cannot be used inside character classes. Tcl and GNU also support POSIX 
word boundaries. <a href="https://www.regular-expressions.info/pcre.html" target="_top">PCRE</a> supports POSIX word boundaries starting with version 8.34. Boost supports them in all its grammars.</p>  <h2>Make a Donation</h2> <p>Did this website just save you a trip to the bookstore? Please <a href="https://www.regular-expressions.info/donate.html">make a donation</a> to support this site, and you'll get a <b>lifetime of advertisement-free access</b> to this site!</p>  <div id="copyright"> <p class="copyright">Page URL: <a href="https://www.regular-expressions.info/wordboundaries.html" target="_top">https://www.regular-expressions.info/wordboundaries.html</a><br> Page last updated: 01 December 2016<br> Site last updated: 03 April 2019<br> Copyright © 2003-2019 Jan Goyvaerts. All rights reserved.</p> </div> </div> <div id="side" style="left: 122px;"><script type="text/javascript">movecontent();</script><table class="side" cellspacing="0" cellpadding="4"><tbody><tr><td class="sideheader">Regex Tutorial</td></tr><tr><td><a href="https://www.regular-expressions.info/tutorial.html" target="_top">Introduction</a></td></tr><tr><td><a href="https://www.regular-expressions.info/tutorialcnt.html" target="_top">Table&nbsp;of&nbsp;Contents</a></td></tr><tr><td><a href="https://www.regular-expressions.info/characters.html" target="_top">Special&nbsp;Characters</a></td></tr><tr><td><a href="https://www.regular-expressions.info/nonprint.html" target="_top">Non-Printable&nbsp;Characters</a></td></tr><tr><td><a href="https://www.regular-expressions.info/engine.html" target="_top">Regex&nbsp;Engine&nbsp;Internals</a></td></tr><tr><td><a href="https://www.regular-expressions.info/charclass.html" target="_top">Character&nbsp;Classes</a></td></tr><tr><td><a href="https://www.regular-expressions.info/charclasssubtract.html" target="_top">Character&nbsp;Class&nbsp;Subtraction</a></td></tr><tr><td><a href="https://www.regular-expressions.info/charclassintersect.html" target="_top">Character&nbsp;Class&nbsp;Intersection</a></td></tr><tr><td><a href="https://www.regular-expressions.info/shorthand.html" target="_top">Shorthand&nbsp;Character&nbsp;Classes</a></td></tr><tr><td><a href="https://www.regular-expressions.info/dot.html" target="_top">Dot</a></td></tr><tr><td><a href="https://www.regular-expressions.info/anchors.html" target="_top">Anchors</a></td></tr><tr><td><a href="https://www.regular-expressions.info/wordboundaries.html" target="_top">Word&nbsp;Boundaries</a></td></tr><tr><td><a href="https://www.regular-expressions.info/alternation.html" target="_top">Alternation</a></td></tr><tr><td><a href="https://www.regular-expressions.info/optional.html" target="_top">Optional&nbsp;Items</a></td></tr><tr><td><a href="https://www.regular-expressions.info/repeat.html" target="_top">Repetition</a></td></tr><tr><td><a href="https://www.regular-expressions.info/brackets.html" target="_top">Grouping&nbsp;&amp;&nbsp;Capturing</a></td></tr><tr><td><a href="https://www.regular-expressions.info/backref.html" target="_top">Backreferences</a></td></tr><tr><td><a href="https://www.regular-expressions.info/backref2.html" target="_top">Backreferences,&nbsp;part&nbsp;2</a></td></tr><tr><td><a href="https://www.regular-expressions.info/named.html" target="_top">Named&nbsp;Groups</a></td></tr><tr><td><a href="https://www.regular-expressions.info/backrefrel.html" target="_top">Relative&nbsp;Backreferences</a></td></tr><tr><td><a href="https://www.regular-expressions.info/branchreset.html" target="_top">Branch&nbsp;Reset&nbsp;Groups</a></td></tr><tr><td><a href="https://www.regular-expressions.info/freespacing.html" target="_top">Free-Spacing&nbsp;&amp;&nbsp;Comments</a></td></tr><tr><td><a href="https://www.regular-expressions.info/unicode.html" target="_top">Unicode</a></td></tr><tr><td><a href="https://www.regular-expressions.info/modifiers.html" target="_top">Mode&nbsp;Modifiers</a></td></tr><tr><td><a href="https://www.regular-expressions.info/atomic.html" target="_top">Atomic&nbsp;Grouping</a></td></tr><tr><td><a href="https://www.regular-expressions.info/possessive.html" target="_top">Possessive&nbsp;Quantifiers</a></td></tr><tr><td><a href="https://www.regular-expressions.info/lookaround.html" target="_top">Lookahead&nbsp;&amp;&nbsp;Lookbehind</a></td></tr><tr><td><a href="https://www.regular-expressions.info/lookaround2.html" target="_top">Lookaround,&nbsp;part&nbsp;2</a></td></tr><tr><td><a href="https://www.regular-expressions.info/keep.html" target="_top">Keep&nbsp;Text&nbsp;out&nbsp;of&nbsp;The&nbsp;Match</a></td></tr><tr><td><a href="https://www.regular-expressions.info/conditional.html" target="_top">Conditionals</a></td></tr><tr><td><a href="https://www.regular-expressions.info/balancing.html" target="_top">Balancing&nbsp;Groups</a></td></tr><tr><td><a href="https://www.regular-expressions.info/recurse.html" target="_top">Recursion</a></td></tr><tr><td><a href="https://www.regular-expressions.info/subroutine.html" target="_top">Subroutines</a></td></tr><tr><td><a href="https://www.regular-expressions.info/recurseinfinite.html" target="_top">Infinite&nbsp;Recursion</a></td></tr><tr><td><a href="https://www.regular-expressions.info/recurserepeat.html" target="_top">Recursion&nbsp;&amp;&nbsp;Quantifiers</a></td></tr><tr><td><a href="https://www.regular-expressions.info/recursecapture.html" target="_top">Recursion&nbsp;&amp;&nbsp;Capturing</a></td></tr><tr><td><a href="https://www.regular-expressions.info/recursebackref.html" target="_top">Recursion&nbsp;&amp;&nbsp;Backreferences</a></td></tr><tr><td><a href="https://www.regular-expressions.info/recursebacktrack.html" target="_top">Recursion&nbsp;&amp;&nbsp;Backtracking</a></td></tr><tr><td><a href="https://www.regular-expressions.info/posixbrackets.html" target="_top">POSIX&nbsp;Bracket&nbsp;Expressions</a></td></tr><tr><td><a href="https://www.regular-expressions.info/zerolength.html" target="_top">Zero-Length&nbsp;Matches</a></td></tr><tr><td><a href="https://www.regular-expressions.info/continue.html" target="_top">Continuing&nbsp;Matches</a></td></tr>
</tbody></table><table class="side" cellspacing="0" cellpadding="4"><tbody><tr><td class="sideheader">More on This Site</td></tr><tr><td><a href="https://www.regular-expressions.info/index.html" target="_top">Introduction</a></td></tr><tr><td><a href="https://www.regular-expressions.info/quickstart.html" target="_top">Regular&nbsp;Expressions&nbsp;Quick&nbsp;Start</a></td></tr><tr><td><a href="https://www.regular-expressions.info/tutorial.html" target="_top">Regular&nbsp;Expressions&nbsp;Tutorial</a></td></tr><tr><td><a href="https://www.regular-expressions.info/replacetutorial.html" target="_top">Replacement&nbsp;Strings&nbsp;Tutorial</a></td></tr><tr><td><a href="https://www.regular-expressions.info/tools.html" target="_top">Applications&nbsp;and&nbsp;Languages</a></td></tr><tr><td><a href="https://www.regular-expressions.info/examples.html" target="_top">Regular&nbsp;Expressions&nbsp;Examples</a></td></tr><tr><td><a href="https://www.regular-expressions.info/reference.html" target="_top">Regular&nbsp;Expressions&nbsp;Reference</a></td></tr><tr><td><a href="https://www.regular-expressions.info/refreplace.html" target="_top">Replacement&nbsp;Strings&nbsp;Reference</a></td></tr><tr><td><a href="https://www.regular-expressions.info/books.html" target="_top">Book&nbsp;Reviews</a></td></tr><tr><td><a href="https://www.regular-expressions.info/print.html" target="_top">Printable&nbsp;PDF</a></td></tr><tr><td><a href="https://www.regular-expressions.info/about.html" target="_top">About&nbsp;This&nbsp;Site</a></td></tr><tr><td><a href="https://www.regular-expressions.info/updates.html" target="_top">RSS&nbsp;Feed&nbsp;&amp;&nbsp;Blog</a></td></tr></tbody></table><iframe class="amazonsingle" marginwidth="0" marginheight="0" scrolling="no" src="Regex%20Tutorial%20-%20_b%20Word%20Boundaries_files/q.html" frameborder="0"></iframe><div><a href="https://www.powergrep.com/"><img class="side" src="Regex%20Tutorial%20-%20_b%20Word%20Boundaries_files/pgr100.png" srcset="ads/pgr100.png 1x, ads/pgr125.png 1.25x, ads/pgr150.png 1.5x, ads/pgr175.png 1.75x, ads/pgr200.png 2x, ads/pgr250.png 2.5x, ads/pgr300.png 3x" alt="PowerGREP—The world’s most powerful tool to flex your regex muscles!"></a></div></div><script type="text/javascript">movecontent();</script><iframe id="google_osd_static_frame_4713855467441" name="google_osd_static_frame" style="display: none; width: 0px; height: 0px;"></iframe></body><iframe id="google_esf" name="google_esf" src="Regex%20Tutorial%20-%20_b%20Word%20Boundaries_files/zrt_lookup.html" style="display: none;" data-ad-client="ca-pub-7485249680256358"></iframe></html>